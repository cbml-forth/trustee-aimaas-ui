export interface ConsumerState {
    currentStepIndex: number;
    maxStepProgress: number;
}

export interface DomainAttr {
    id: number;
    domain_id: number;
    name: string;
}
export interface Domain {
    id: number;
    name: string;
    description: string;
    attributes: DomainAttr[];
}

export interface User {
    id: string;
    name: string;
    email: string;
    tokens: {
        id_token: string;
        access_token: string;
        expires_in?: number;
        expires_at?: number;
    };
    session_id: string;
}

export interface ModelSearchAttributeCriterion {
    attribute: DomainAttr;
    value: string;
}
export interface ModelSearchCriterion {
    domain: Domain;
    attributes: ModelSearchAttributeCriterion[];
}

export interface ModelSearchResponseItem extends Record<string, unknown> {
    id: number;
}

export type SSISearchCriterionOperator = "equal" | "notequal" | "contains";
export interface SSISearchCriterion {
    domain: Domain;
    attribute: DomainAttr;
    operator: SSISearchCriterionOperator;
    value: string;
}
export type SSISearchStatus = "NOT STARTED" | "ACCEPTED" | "FINISHED" | "ERROR";
export interface SSISearchResponse {
    status: SSISearchStatus;
    process_id?: string;
}
export interface SSISearchPollResponse {
    status: SSISearchStatus;
    datasets_id?: string[];
}

export type ProcessStatus =
    | "NOT STARTED"
    | "IN PROGRESS"
    | "FINISHED"
    | "BLOCKED"
    | "FAILED";

export interface ProsumerWorkflowSSIData {
    process_id: string;
    status: SSISearchStatus;
    criteria: SSISearchCriterion[];
    global_models: ModelSearchResponseItem[]; // Global models matching SSI criteria if found
    results?: string[]; // Results, "model ids"
}

export interface FLProcessStatusData {
    current_round: number;
    total_rounds: number;
    rounds_completed: number;
    has_completed: boolean;
    has_failed: boolean;
    status: string;
}

export interface ProsumerWorkflowFLData {
    process_id: string;
    status: FLProcessStatusData;
    number_of_rounds: number;
    models: string[];
    computation: string;
    solver: string;
    denoiser: string;
    num_of_iterations: number;
}

export interface ProsumerWorkflowData {
    readonly id: string; // "prosumer id"
    name: string;
    ssi: ProsumerWorkflowSSIData; // this is for "step 1"
    models_selected: string[]; // step2 when completed fills this
    fl_process?: ProsumerWorkflowFLData; // step3 fills the fl parameters and starts FL process
    kg_results: string[];
}

export interface ConsumerWorkflowData {
    readonly id: string; // "consumer id"
    step1_search: ModelSearchCriterion; // this is for "step 1"
    step1_results?: ModelSearchResponseItem[];
    selected_model_id?: number; // if it was selected then we have redirected to STM
    agreements_signed?: boolean; // if this is not undefined then we have get the response from the STM
    model_downloaded?: boolean;
}

/*

Example:
{
  "data-provider-IDs": ["8", "9"],
  "model-consumer-endpoint": "https://trustee-test-hedf-mc.cybersec.digital.tecnalia.dev",
  "computation": "Simple Averaging",
  "process-ID": "test-MultiFL-018",
  "number-of-rounds": 2
}

Field Descriptions:

| Field                     | Type   | Description                                           |
| --- ----------------------| ------ | -------------------------                             |
| data-provider-IDs         | array  | List of data provider IDs, retrieved from DL (exists) |
| model-consumer-endpoint   | string | Provided by the user (exists) |
| computation               | string | Computation type (e.g., "Simple Averaging") (exists) |
| process-ID                | string | Unique process identifier, generated by the UI (exists) |
| number-of-rounds          | int    | Number of FL rounds, must be > 0 (tbd) |

*/

export interface FLStartAggregationRequest {
    dataProviderIDs: string[]; // json: "data-provider-IDs"
    modelConsumerEndpoint: string; // json: "model-consumer-endpoint"
    computation: string; // json: "computation"
    processID: string; // json: "process-ID"
    numberOfRounds: number; // json: "number-of-rounds"
    fl_initialization_model?: number;
}

export interface ProviderWorkflowData {
    readonly id: string; // "provider id"
    model_provider_id: string; // step1: model provider id (user's sub)
    fl_endpoint: string; // fl endpoint, comes from DL stored in the "AIMaaS/Providers" resource

    model_id?: number;
    global_model_id?: number;
    name?: string;
    model_description?: string; // step1: model description
    domain_id?: number; // step1: domain id
    credential_id?: string; // step1: credential id
    source_url?: string; // step1: source url
    ecosystem?: string; // step1: ecosystem (Trustee, Gaiax, Copernicus, IDS)
    agreements_created?: boolean; // step5: agreements signed status
    model_uploaded?: boolean; // step6: model and files uploaded
}

export interface ProviderModelData {
    id?: number;
    global_model_id?: number;
    process_id: string;
    domain_id: number;
    credential_id: string;
    model_provider_id: string;
    source_url: string;
    source: string;
    format: string;
    trained: boolean;
}

export function ssi_criteria_to_ast(crits: SSISearchCriterion[], logical_operator?: string | undefined): string {
    if (logical_operator === undefined) {
        logical_operator = "and";
    }

    const filters = crits.map((c) => {
        const domain = c.domain.name.toLowerCase();
        const type = c.attribute.name;
        const value = c.value;
        let operation;
        switch (c.operator.toLowerCase()) { // Enum: ["equal", "notequal", "contains"] See https://github.com/Trustee-Horizon/SSIHE-API
            case "equal":
            case "equals":
                operation = "=";
                break;
            case "notequal":
            case "not equal":
                operation = "!=";
                break;
            case "contains":
                operation = "â‰ˆ";
                break;
            case "greater_than":
                operation = ">";
                break;
            case "less_than":
                operation = "<";
                break;
            default:
                operation = c.operator.toLowerCase();
        }
        return `(${domain}.${type} ${operation} '${value}')`;
    });
    return filters.sort().join(` ${logical_operator.toLowerCase()} `);
}
